   ---
The Nomin framework's simple mapping rules
   ---

Simple mapping rules

  Mapping rules are defined as usual assignments, but they actually work in both directions.

  Mapping affectors/specificators, if exist, should follow a mapping rule they affect. Affectors specifies details of
  data transferring such as conversions, type hints, using different mapping cases. This will be covered in the rest of
  the documentation.

  Do not forget to define mapping sides, classes to be mapped to each other. Let's start.

+---
  mappingFor a: Person, b: Employee // this defines mapping sides

  a.name = b.name
  a.lastName = b.last

  a.birthDate = b.details.birth // we go deep through the object tree not limited with one level

  a.children = b.details.kids // there are collections of complex types on the sides

  a = b.details // propagating the state of a instance to b.details and vice versa
+---

  Quite often relations between the models are not so simple as the above. Suppose we have a collection on the first side
  and a single element on another. You can address desired element of a collection or an array using square braces.

+---
  a.children[0] = b.details.kids[0] // we are processing the first child/kid only
  a.educationName = b.details.educations[0].name
  a.educationDescription = b.details.educations[0].description
+---

  Does Nomin have the ability to use some static value instead of value of a property? Of course!

+---
  a.version = 1
  a.message = "Just some message"

  b.parsingDate = new Date()
  b.mappedBy = "Nomin"
+---

  Note that <<<a.version>>> and <<<a.message>>> will be set into specified values during mapping b instance to a instance.
  And consequently <<<b.parsingDate>>> and <<<b.mappedBy>>> will be set during mapping a instance to b instance.
  Parts of mapping rules on the right are calculated only once during parsing a mapping, i.e. <<<b.parsingDate>>> will
  not be recalculated every time during mapping.

